 * Example C expression
 * (1 + 2 * (3 + 4 * (5 + 6 * 7 * (8 + 9))))
 * 
 * And how it will get written to interpreted file.
 * NOTE that we'll go R2L through this list until we find an OPR8R followed by the
 * required # of operands; in this case [8] [9] [+]. Note that in the above C expression,
 * 8 + 9 is in the most deeply nested parentheses and therefore has the highest precedence
 * [1]  [2]  [3]  [4]  [5]  [6]  [7]  [*]  [8]  [9]  [+]  [*]  [+]  [*]  [+]  [*]  [+] 
 * [1]  [2]  [3]  [4]  [5]           [42]           [17]  [*]  [+]  [*]  [+]  [*]  [+] 
 * [1]  [2]  [3]  [4]  [5]                              [714]  [+]  [*]  [+]  [*]  [+] 
 * [1]  [2]  [3]  [4]                                        [719]  [*]  [+]  [*]  [+] 
 * [1]  [2]  [3]                                                 [2876]  [+]  [*]  [+] 
 * [1]  [2]                                                           [2879]  [*]  [+] 
 * [1]                                                                     [5758]  [+] 
 *                                                                              [5759]

 * Example nested ternary C expression
 * (count == 1 ? "one" : count == 2 ? "two" : count == 3 ? "three" : count == 4 ? "four" : "MANY")

 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [count]  [1]  [==]  [?] 

 * **************************************************************************************************************************************************************
 * count = 1;
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [count]  [1]  [==]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [1]  [?] 

 * Somehow we've got to skip over all the junk to get to the [one] at the end
 * We're moving BACKWARDS through the list, so L&R for the [:] OPR8R are in reverse order.

 * [one]  [two]  [three]  [four]  [MANY]  
 * [:]  [count]  [4]  [==]  [?]  -> pulls off [four] [MANY] because this branch was never reached
 * [:]  [count]  [3]  [==]  [?]  -> pulls off [three] because the false branch was already pulled off above
 * [:]  [count]  [2]  [==]  [?]  -> pulls off [two] because the false branch was already pulled off above
 * [:]  [1]  [?] -> this is finally resolved as [one]


 * **************************************************************************************************************************************************************
 * count = 2;
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [count]  [1]  [==]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [0]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [1]  [?]

 * [one]  [two]  [three]  [four]  [MANY]  
 * [:]  [count]  [4]  [==]  [?]  -> pulls off [four] [MANY] because this branch was never reached
 * [:]  [count]  [3]  [==]  [?]  -> pulls off [three] because the false branch was already pulled off above
 * [:]  [1]  [?]  -> After previous scopes popped, we grab the 1st available -> [two]
 * 

 * **************************************************************************************************************************************************************
 * count = 3;
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [count]  [1]  [==]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [0]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [0]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [1]  [?]  

 * [one]  [two]  [three]  [four]  [MANY]  
 * [:]  [count]  [4]  [==]  [?]  -> pulls off [four] [MANY] because this branch was never reached  
 * [:]  [1]  [?]  -> After previous scopes popped, we grab the 1st available -> [three]  


 * **************************************************************************************************************************************************************
 * count = 4;
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [count]  [1]  [==]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [0]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [0]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [0]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [1]  [?]

 * [one]  [two]  [three]  [four]  [MANY]  
 * [:]  [1]  [?] -> There are 2 possibilities for us to grab; Since it's the TRUE path and we're running in REVERSE, pick the 2nd* resolved token [four]
 * 2nd going from R2L, which would in turn be 1st in L2R order for that expression 2-tuple
 * 
 * 
 * **************************************************************************************************************************************************************
 * count = 5;
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [count]  [1]  [==]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [count]  [2]  [==]  [?]  [:]  [0]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]  [:]  [0]  [?] 
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [count]  [3]  [==]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]  [:]  [0]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [count]  [4]  [==]  [?]
 * [one]  [two]  [three]  [four]  [MANY]  [:]  [0]  [?]
 * 
 * [one]  [two]  [three]  [four]  [MANY]  
 * [:]  [0]  [?] -> There are 2 possibilities for us to grab; Since the FALSE path is valid and we're running in REVERSE, pick the 1st* resolved token [MANY]
 * 1st going from R2L, which would in turn be 2nd in L2R order for that expression 2-tuple


